\chapter{Related Works}
In recent years, publications targetting the topic of clustering arguments in AFs have been released. One of the first papers been written in this field was the paper ''Existential Abstraction on Argumentation Frameworks via Clustering`` from Saribatur and Wallner \cite{DBLP:conf/kr/SaribaturW21}. Since then, a tool was created (absarg-clustering) \footnote{https://github.com/rbankosegger/absarg-clustering} to determine faithfulness and spuriousness of an AF and automatically finding non-spurious partitions. Furthermore, every two years the International Competitions on Computational Models of Argumentation (ICCMA) \cite{COMP:ICCMA2023} runs a competition, aiming to assess the state of the art in practical systems for reasoning in central argumentation formalisms.

\paragraph{Absarg-clustering} The project called \emph{absarg-clustering} is a tool to simplify the Dung-Style argumentation frameworks by partitioning arguments into clusters. The tool was developed in 2022 and is available on GitHub under the open-source license GPL-3.0. It is a similar implementation to our tool but uses Answer Set Programming (ASP) with the clingo solver \cite{gebser_et_al:OASIcs.ICLP.2016.2} in combination with Python3. The tool covers solutions to various problems, e.g., \ computing classical extensions, checking whether an extension is spurious, or finding spurious extensions from an abstract AF.

After some minor test-runs with the faithful/spurious check, we can see that it performs similar to the BFS implementation of our tool with no refinements and the SAT-based check. Since DFS is faster than BFS in the most cases, our tool is more efficient than \emph{absarg-clustering} when choosing the best settings.


\paragraph{ICCMA Competition} The International Competitions on Computational Models of Argumentation (ICCMA) runs a competition designed to foster research and development in implementing computational models of argumentation. The first competition was in 2015 and was associated with the workshop ''Theory and Applications of Formal Argument (TAFA'15)``. Back then, the covered semantics were \emph{complete}, \emph{preferred}, \emph{grounded}, and \emph{stable}. The main task was to compute semantics extensions and decide whether a given argument is credulously or skeptically inferred. Over the years, the competition evolved, and now there are multiple so-called ''tracks``, each with a different focus and different problem settings. The credulous/skeptical check is still one of the tracks called ''Dynamic Track``. After all the competitors have sent in their solutions, benchmark tests are executed for all the submissions, and a final ranking is published afterward.

Since 2015, the competition has been hosted every two years, and researchers worldwide can participate. The last competition hosted by the ICCMA in 2023 was won by the researcher team from the University Artois \& CNRS with the name \texttt{Crustabri} \footnote{https://github.com/crillab/crustabri} and second place was awarded to the solver from the University of Helsinki with the name \texttt{$\mu$-Toksia} \footnote{https://bitbucket.org/andreasniskanen/mu-toksia} \cite{DBLP:conf/kr/NiskanenJ20a}.


\paragraph{Abstraction in other fields} Abstraction is not only used in combination with argumentation frameworks, but does also find the application in model building and problem solving. It is an important technique to reduce the complexity of the program and still being able to find a solution. Abstraction is also explored in the context of non-ground Answer Set Programming (ASP) \cite{inproceedings:AbstractionInOtherDomains}. An often used example in the concept of ASP is Sudoku, which is a puzzle played on a 9$\times$9 grid. With abstraction, we can encode the rules of the puzzle by considering higher-level constraints like focusing on rows, columns and blocks.

Abstraction is also applied in the context of model-checking \cite{10.1145/876638.876643}. In this paper, abstraction is applied to the state explosion of symbolic model checking. In the presented method, an initial abstract model is generated which may be erroneous. This erroneous abstraction is refined over and over until no counterexamples can be found. This procedure can be compared to our implementation of concretizing arguments until faithfulness is reached.

\paragraph{Encodings of AF semantics} 




