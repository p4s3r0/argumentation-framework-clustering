\chapter{Background}
\label{ch:Background}
In this chapter we will discuss the background of the thesis. We will start with the basic definition of argumentation frameworks (AFs) in \cref{sec:ArgumentationFrameworks}. Next we will treat the clustering of AFs in \cref{sec:ClusteringOfArgumentationFrameworks} and finally we will have a look at SAT-Solver in \cref{sec:BooleanSatisfiability}.

\textit{TODO: update when adding sections}


\section{Argumentation Frameworks}
\label{sec:ArgumentationFrameworks}

Argumentation frameworks were first formally described by Dung in 1995 \cite{DUNG1995321}. They represent an information state, where various conclusions can be drawn from. An AF $\mathtt{G = (A, R)}$ consists of two parameters: a set of arguments $\mathtt{A}$, and a collection of relations $\mathtt{R}$, called attacks which describe the conflicts between the arguments.

They are mostly used in the fields of Artificial Intelligence (AI), e.g. in automated reasoning and logic programming \cite{AFINAIARLP, AFINAIARLPexample}. But do also find their applications in other fields like Natural Language Processing \cite{AFINNLP}, Trust and Reputation Systems \cite{AFINTaRS}, Legal and Medical Reasoning \cite{legalAndMedicalReasoning}, and even in Game Theory and Strategic Reasoning \cite{AFinGames}.

AFs are represented by directed graph, where the nodes are an abstraction of the arguments $\mathtt{A}$, and the arrows represent the attacks $\mathtt{R}$. Let us define an AF $\mathtt{G = (A, R)}$ with the arguments
$\mathtt{A=\{a, b, c, d, e\}}$ and the attacks
$\mathtt{R=\{(a,b),}$
$\mathtt{(b,b),}$
$\mathtt{(a,c),}$
$\mathtt{(c,a),}$
$\mathtt{(c,d),}$
$\mathtt{(d,e),}$
$\mathtt{(e,d)\}}.$

This AF can be represented as a directed graph as shown in \cref{af:backgroundAFexample1}.
\begin{example}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}     \def \ay{0}
        \def \bx{1}     \def \by{0}
        \def \cx{1}     \def \cy{-1}
        \def \dx{2}     \def \dy{0}
        \def \ex{3}     \def \ey{0}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};

        % Attacks
        \DrawAttackHorizontal{R}{\ax}{\ay}{\bx}{\by}
        \DrawSelfAttackRightSingleton{\bx}{\by}
        \DrawAttackDiagonal{NB}{\ax}{\ay}{\cx}{\cy}
        \DrawAttackDiagonal{PLR}{\cx}{\cy}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\dx}{\dy}
    \end{tikzpicture}
    \caption{\ac{AF} $\mathtt{G}$}
    \label{af:backgroundAFexample1}
\end{example}

To be able to conclude something, out of an abstract AF, we need to define semantics. Semantics define a subset of argument sets that satisfy the semantic-specific rules. Dung already defined different semantics \cite{Dung1995-DUNOTA-2} like conflict-free, admissible and stable.

\newpage
\paragraph{Conflict-Free} According to Dung's definitions, a set is conflict-free if there are no attacks between the arguments in the conflict-free set. Or, formally:

\begin{definition}
    Let $\mathtt{G=(A,R)}$ be an AF. Then a set $S \subseteq A$ is conflict-free in $G$ iff for each $a, b \in S$ we have $(a, b) \not\in R$.
\end{definition}

A conflict-free set is mainly a building block for the other semantics, which means here that each admissible set or stable extension is conflict-free.

In the \cref{af:backgroundAFexample1} the \emph{conflict-free} sets are:
$\mathtt{\{\}},$
$\mathtt{\{a\}},$
$\mathtt{\{c\}},$
$\mathtt{\{d\}},$
$\mathtt{\{e\}},$
$\mathtt{\{a, d\}},$
$\mathtt{\{a, e\}},$
$\mathtt{\{c, e\}}$.

\paragraph{Admissible}  According to Dung's definitions, a set is admissible, if each argument in the admissible set has a defender in the admissible set. Or, formally:

\begin{definition}
    Let $\mathtt{G=(A,R)}$ be an AF. Then a set $S \subseteq A$ is admissible in $G$, iff $S \in cf(G)$ and if $a \in S$ with $(b, a) \in R$, then there is a $c \in S$ with $(c, b) \in R$.
\end{definition}


In the \cref{af:backgroundAFexample1} the \emph{admissible} sets are:
$\mathtt{\{\}},$
$\mathtt{\{a\}},$
$\mathtt{\{c\}},$
$\mathtt{\{e\}},$
$\mathtt{\{a, d\}},$
$\mathtt{\{a, e\}},$
$\mathtt{\{c, e\}}$.


\paragraph{Stable}  According to Dung's definitions, a set is stable, if it is conflict-free, and if for every argument, which is not in the stable extension, there exists an attacker in the stable extension. Or, formally:

\begin{definition}
    Let $\mathtt{G=(A,R)}$ be an AF. Then a set  $S \subseteq A$ is stable in $G$. iff $S \in cf(G), b \not\in S$ implies that there is an $a \in S$ with $(a, b) \in R$, and if $S$ does not attack an $a \in S$ then $b \not\in S$ whenever $(a, b) \in R$.
\end{definition}


In the \cref{af:backgroundAFexample1} the \emph{stable} sets are:
$\mathtt{\{a, d\}},$
$\mathtt{\{a, e\}}$.

\vspace{0.5cm}
\noindent
The specific semantics rules can also be defined via a Boolean formula. Which then can be used to encode the AFs to be solvable with different solvers like \ac{ASP} \cite{DBLP:journals/corr/abs-1301-1388} or, as in our case, with a \ac{SAT-Solver} \cite{DBLP:journals/amai/AmgoudD13}. Unfortunately, drawing a conclusion from an AF can be challenging, e.g., it can be NP-complete and sometimes even be beyond NP to decide whether an argument is acceptable (whether an argument can be defended successfully against attacks within the AF) under a specific argumentation semantics \cite{DBLP:journals/ai/DvorakGRW23}.



\section{Clustering of Argumentation Frameworks}
\label{sec:ClusteringOfArgumentationFrameworks}

When talking about AFs in general, we already have an abstraction layer. By clustering, we add another layer of abstraction where we combine different arguments into one or multiple so called \textit{clusters}. The arguments which are not clustered are called \textit{singletons}. The name is derived from set theory, where singleton refers to a set containing exactly one argument.
By definition, a cluster is a single entity (composed of multiple arguments) which can be integrated in an AF to reduce the complexity. While reducing the overall complexity of the AF with clusters, we add a new computation layer: computing \textit{faithful} clustered AFs. The term \textit{faithful} describes the property of a clustered AF, that every abstract semantics extension can be mapped to a concrete semantics extension. If the clustered AF creates a semantic set which cannot be mapped to a concrete set, we call it \textit{spurious}.

Clustered abstract AFs can also be modelled with graphs. One can represent each singleton argument as a node, attacks as arrows, and each cluster can be represented by a rectangle with every clustered argument inside of it. Let us have a look at an example and define AF $\mathtt{\hat{G}=(\hat{A}, \hat{R})}$ with the arguments $\mathtt{\hat{A}=\{d, e, \hat{h}\}}$, where the cluster $\mathtt{\hat{h}}$ contains the arguments $\mathtt{\{a, b, c, d\}}$ and the attacks being $\mathtt{\{(\hat{h}, d), (d, e), (e, d), (\hat{h}, \hat{h})\}}$.  This AF can be represented as a directed graph as shown in \cref{af:backgroundExampleClusterSpurious}.


\begin{example}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ex{3}     \def \ey{0}
        \def \dx{2}     \def \dy{0}
        \def \hx{0}     \def \hy{0}

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$a,b,c,d$};
        \node at (0, 0.55) {$\hat{h}$};
        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};

        % Attacks
        \DrawSelfAttackLeftTopCluster{\hx-0.65}{\hy + 0.3}
        \DrawAttackHorizontal{R}{\hx+0.5}{\hy}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\dx}{\dy}
    \end{tikzpicture}
    \caption{\ac{AF} $\mathtt{\hat{G}}$ clustered}
    \label{af:backgroundExampleClusterSpurious}
\end{example}


%\textit{TODO: Definition of Semantics}
Since clusters can not be treated the exact same way as an argument, we need to refine the semantics definitions. When referring to the alternative semantics used in clustered AFs, we call them \emph{abstract} semantics (e.g. abstract conflict-free ($\hat{cf}$), abstract admissible ($\hat{adm}$) and abstract stable ($\hat{stb}$)). Let us consider a clustered AF $\mathtt{\hat{G}=\{\hat{A}, \hat{R}\}}$ and redefine the semantics.

\paragraph{Conflict-Free} A set of arguments is abstractly conflict-free, if there is no attack between the singletons of the set. Or, formally, as specified in \cite{DBLP:conf/kr/SaribaturW21}:

\begin{center}
    \begin{tabular}{c}
        $\hat{S} \in \hat{cf}(\hat{G})$ \textit{iff for each} $\hat{a}, \hat{b} \in$ \textit{singleton}($\hat{S}$) \textit{we have} $(\hat{a}, \hat{b}) \not\in \hat{R}$.
    \end{tabular}
\end{center}

In the \cref{af:backgroundExampleClusterSpurious} the abstract conflict-free sets are:
$\mathtt{\{\}},$
$\mathtt{\{d}\}$,
$\mathtt{\{e}\}$,
$\mathtt{\{\hat{h}}\}$,
$\mathtt{\{e, \hat{h}}\}$,
$\mathtt{\{d, \hat{h}}\}$.



\paragraph{Admissible} A set of arguments is abstractly admissible, if it is abstractly conflict-free and if every singleton which is being attacked, has a defender. Or, formally, as specified in \cite{DBLP:conf/kr/SaribaturW21}:

\begin{center}
    \begin{tabular}{c}
        $\hat{S} \in \hat{adm}(\hat{G})$ \textit{iff} $\hat{S} \in \hat{cf}(\hat{G})$\\

        \textit{and if} $\hat{a} \in \hat{S}$ \textit{with} $(\hat{b}, \hat{a}) \in \hat{R}$ \textit{with singleton}($\hat{a}$),\\

        \textit{then there is a} $\hat{c} \in \hat{G}$ \textit{with} $(\hat{c}, \hat{b}) \in \hat{R}$.
    \end{tabular}
\end{center}

In the \cref{af:backgroundExampleClusterSpurious} the abstract admissible sets are:
$\mathtt{\{\}},$
$\mathtt{\{e}\}$,
$\mathtt{\{\hat{h}}\}$,
$\mathtt{\{e, \hat{h}}\}$,
$\mathtt{\{d, \hat{h}}\}$.



\paragraph{Stable} A set of arguments is abstractly stable, if it is abstractly conflict-free and if an argument is not in the abstractly stable set, it implies that an argument in the abstractly stable set is attacking it. Furthermore if the abstractly stable set is not attacking an argument, then every singleton attacking the argument is not in the abstractly stable set. Or, formally, as specified in \cite{DBLP:conf/kr/SaribaturW21}:
\begin{center}
    \begin{tabular}{c}
        $\hat{S} \in \hat{stb}(\hat{G})$ \textit{iff} $\hat{S} \in \hat{cf}(\hat{G}),  \hat{b} \not\in \hat{S}$ \textit{implies}\\

        \textit{that there is an} $\hat{a} \in \hat{S}$ \textit{with} $(\hat{a}, \hat{b}) \in \hat{R}$,\\

        \textit{and if} $\hat{S}$ \textit{does not attack an} $\hat{a} \in \hat{S}$ \textit{then} $\hat{b} \not\in \hat{S}$\\

        \textit{whenever} $(\hat{a}, \hat{b}) \in \hat{R}$ \textit{and singleton}$(\hat{b})$.
    \end{tabular}
\end{center}

In the \cref{af:backgroundExampleClusterSpurious} the abstractly stable sets are
$\mathtt{\{e, \hat{h}}\}$,
$\mathtt{\{d, \hat{h}}\}$.

\vspace{0.5cm}
\noindent
Let us have a look at a concrete example to explain faithfulness. The concrete AF $\mathtt{G=(A, R)}$ has the following arguments $\mathtt{A=\{a, b, c, d, e\}}$ with these attacks:
$\mathtt{R=\{(a,b),}$
$\mathtt{(b,b),}$
$\mathtt{(a,c),}$
$\mathtt{(c,a),}$
$\mathtt{(c,d),}$
$\mathtt{(d,e),}$
$\mathtt{(e,d)\}}$.

This AF can be represented as a directed graph shown in \cref{af:backgroundClusterExample1}.

Now we can group the arguments $\mathtt{\{a, b, c, d\}}$ together into one single cluster $\mathtt{\hat{h}}$. The arguments for the abstract AF $\mathtt{\hat{G} = (\hat{A}, \hat{R})}$ would then be $\mathtt{\hat{A}=\{e, \hat{h}\}}$, where the cluster $\mathtt{\hat{h}}$ is composed of $\mathtt{\{a, b, c, d\}}$ and the according attacks are
$\mathtt{\hat{R}=\{(\hat{h}, e), (e, \hat{h}), (\hat{h}, \hat{h})\}}$. The attacks are directly derived from the concrete AF. If an argument is clustered, the cluster inherits the attacks from the argument. The emerging AF can be represented as a directed graph shown in \cref{af:backgroundClusterExample2}.


\vspace{0.3cm}
\begin{example}[h]
\begin{minipage}{.5\textwidth}
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}     \def \ay{0}
        \def \bx{1}     \def \by{0}
        \def \cx{1}     \def \cy{-1}
        \def \dx{2}     \def \dy{0}
        \def \ex{3}     \def \ey{0}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};

        % Attacks
        \DrawAttackHorizontal{R}{\ax}{\ay}{\bx}{\by}
        \DrawSelfAttackRightSingleton{\bx}{\by}
        \DrawAttackDiagonal{NB}{\ax}{\ay}{\cx}{\cy}
        \DrawAttackDiagonal{PLR}{\cx}{\cy}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\dx}{\dy}
    \end{tikzpicture}
    \caption{Concrete AF $\mathtt{G}$}
    \label{af:backgroundClusterExample1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ex{2}     \def \ey{0}
        \def \hx{0}     \def \hy{0}

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$a,b,c,d$};
        \node at (0, 0.55) {$\hat{h}$};
        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};

        % Attacks
        \DrawSelfAttackLeftTopCluster{\hx-0.65}{\hy + 0.3}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\hx+0.5}{\hy}
    \end{tikzpicture}
    \caption{Abstract AF $\mathtt{\hat{G}}$}
    \label{af:backgroundClusterExample2}
\end{minipage}
\end{example}

If we compare the stable sets of the concrete AF $\mathtt{G}$ (e.g. $\mathtt{stb=\{\{a, e\}, \{a, d\}\}}$) with the abstractly stable sets of the abstract clustered AF $\mathtt{\hat{G}}$ (e.g. $\mathtt{\hat{stb}=\{\{\hat{h}\}, \{e\}, \{e, \hat{h}\}\}}$), we see that it is spurious due to the abstractly stable set $\mathtt{\{e\}}$ which cannot be mapped to one of the concrete stable sets. The mapping of semantic extensions with clustered AFs is done the same way as for concrete AFs, except that clusters can mutate to every possible combination of the clustered Arguments. In our example, the cluster $\mathtt{\hat{h}}$ can mutate to $\mathtt{\{a\}}$, $\mathtt{\{b\}}$, $\mathtt{\{c\}}$, $\mathtt{\{d\}}$, $\mathtt{\{a, b\}}$, $\mathtt{\{a, c\}}$, $\mathtt{\{a, d\}}$, $\mathtt{\{b, c\}}$, $\mathtt{\{b, d\}}$, $\mathtt{\{c, d\}}$, $\mathtt{\{a, b, c\}}$, $\mathtt{\{a, b, d\}}$, $\mathtt{\{a, c, d\}}$, $\mathtt{\{b, c, d\}}$, $\mathtt{\{a, b, c, d\}}$.
To create a faithful clustered AF, we can concretize one or more arguments of the cluster. By concretizing the argument $\mathtt{\{d\}}$, we obtain a new AF $\mathtt{\hat{G}'=(\hat{A}', \hat{R}')}$ with the arguments $\mathtt{\hat{A}'=\{d, e, \hat{h}\}}$, where the cluster $\mathtt{\hat{h}}$ is composed of $\mathtt{\{a, b, c\}}$, and the according attacks are $\mathtt{\hat{R}'=\{(d, \hat{h}),}$
$\mathtt{(d, e),}$
$\mathtt{(e, d),}$
$\mathtt{(\hat{h}, \hat{h})\}}$.

With this defintion we can build the concretized abstract graph $\mathtt{\hat{G}'}$ in \cref{af:backgroundClusterExample3}.


\begin{example}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ex{3}     \def \ey{0}
        \def \dx{2}     \def \dy{0}
        \def \hx{0.4}     \def \hy{0}

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$a,b,c$};
        \node at (0.4, 0.55) {$\hat{h}$};
        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};

        % Attacks
        \DrawSelfAttackLeftTopCluster{\hx-0.42}{\hy + 0.3}
        \DrawAttackHorizontal{R}{\hx+0.25}{\hy}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\dx}{\dy}
    \end{tikzpicture}
    \caption{Concretized AF $\mathtt{\hat{G}'}$}
    \label{af:backgroundClusterExample3}
\end{example}

Every abstractly stable set in \cref{af:backgroundClusterExample3} (e.g. $\mathtt{\{d, \hat{h}\}, \{e, \hat{h}\}})$ can be mapped to one of concrete stable sets of $\mathtt{G}$, which means that the clustered AF $\mathtt{\hat{G}'}$ is faithful.


\section{Boolean Satisfiability}
\label{sec:BooleanSatisfiability}

A SAT(isfability)-Solver is used to compute Boolean formulas in a rather efficient way \cite{Biere2009}. The main purpose is to determine, if a formula is satisfiable (e.g. the variables of the formula can be set to \textit{true} or \textit{false} s.t. the expression evaluates to \textit{true}). If no combination of setting the variables to \textit{true} or \textit{false} s.t. the formula evaluates to \textit{true} is found, we call the Boolean expression UNSAT(isfiable). Most of the SAT-Solvers do also provide a model, if a Boolean expression is satisfiable.

SAT-Solvers do find there applications in various domains, f.e. in verification and validation of software and hardware \cite{DBLP:conf/dagstuhl/Gogolla09, DBLP:books/daglib/0045943}. But also in AI and machine learning \cite{DBLP:phd/basesearch/Liang18a} and even in security~\cite{Pasero2022-SATHashFunctions-Repo, DBLP:journals/iacr/LinYXTS24}.

%\textit{TODO: Complexity of SAT-Problems}
The decision problem of deciding whether a Boolean formula is satisfiable (SAT) is NP-complete, and it was the first problem to be shown to be NP-complete \cite{Cook71}. Subsequently, many other problems were shown to be NP-hard, due to a reduction from SAT.


Each year further optimizations of SAT-solvers are developed. There are several competitions which are being ran in different classes \cite{SAT-Solver-Competition}. Meanwhile, SAT-Solvers are so specialized, that there is no overall best SAT-Solver, but it is dependent on the application field. An overall good performing and easy to implement SAT-Solver, which we also used in this thesis is the z3 SAT-Solver \cite{z3-SAT-Solver}.



