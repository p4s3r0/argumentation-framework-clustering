\chapter{Conclusions}
This thesis aimed to investigate the efficiency of SAT-Solvers within the context of clustered argumentation frameworks. We applied the SAT-Solver z3 to solve four different problems. Our tool is called \prog\ and is available on GitHub under the open-source MIT license. Furthermore, we designed refinements covering all implemented semantics, i.e., conflict-free, admissible, and stable. These refinements are supposed to speed up the process of solving the task.

Additionally, we developed two different algorithms, i.e., BFS and DFS, which operate differently, and thus, one dominates the other depending on the input AFs. We ran benchmarks to determine the effect of the refinements, which algorithm is more dominant, and under which circumstances. In order to cover a variety of different AFs, we used three different AF generator procedures, i.e., random-based, grid-based, and level-based.

In this concluding chapter, the key findings are summarized, and their implications of practicality are discussed. To wrap up this research, we also stated the efficiency of the refinements and under which circumstances one algorithm dominates the other. Finally, we will discuss the limits and issues of our implementation and how it could be improved in future works.

\paragraph{Refinements} Let us begin by discussing the impact of the refinements. As data has shown, the refinements for admissible and stable had a minimal impact. We hypothesize that the SAT-Solver has to invest more computation time for a single extension by adding the refinement to the Boolean formula and almost doubling it. Nevertheless, due to the refinement, we are reducing the total amount of extensions that need to be calculated. We assume these factors cancel out, and the runtime is not significantly improved. However, for conflict-free, the refinements contribute to a big improvement in the runtime for most instances. There are some outliers at spurious AFs, which can be attributed to a spurious extension found by the DFS algorithm. For faithful AFs, the refinement will always contribute to a lower runtime.


\paragraph{BFS vs DFS} Next, we will debate the choice of faithful/spurious check algorithm. The BFS approach is the algorithm with more stability, computing independently from the seed of the SAT-Solver. This is because BFS calculates all the semantic extensions before checking for spuriousness. Therefore, the order in which the extensions are calculated does not matter. BFS shows better results than DFS if the input AFs are faithful since there are no context switches. The same holds for AFs with very few semantics extensions. However, DFS dominates BFS in every other aspect. DFS is highly dependent on the seed of the SAT-Solver and can show spuriousness more efficiently without computing all of the faithful semantic extensions. The DFS algorithm scales well with the size of the AFs by finding solutions even for AFs with 30 arguments.

Nevertheless, for faithful AFs, the runtime is the same as BFS, with an additional overhead of the context switches. We recommend using the BFS algorithm for small AFs (with fewer arguments than 15) and if the probability of faithfulness is high. For bigger AFs (with more than 15 arguments), we recommend using DFS.

\paragraph{Limits and issues} We pushed \prog\ to the limits and analyzed the issues. First of all, the tool does not scale well with the size of the AFs. If the number of arguments increases, the computation time of generating semantic extensions also increases, leading to a higher runtime for all the implemented programs. Furthermore, the concretizing arguments program is not guaranteed to find a solution. This is due to the restriction of the neighbors depth (which in our implementation is $2$). By increasing the depth, s.t., the depth equals the number of arguments the AF has, we could guarantee to find a solution. However, it would also aggravate the last issue: exponential growth of the combination table when computing the concretized list. The concretized list defines the arguments to be concretized until faithfulness is reached and depends on the number of neighbors a spurious argument has. With each new neighbor, we increase the combination table by a factor of $2$. Therefore, by increasing the depth of neighbors, we could generate a combination table taking up so much memory that the computation is infeasible to solve.


\paragraph{Future Work} If the usage of SAT-Solvers should be preserved, the tool could be improved by substituting the current SAT-Solver (i.e., \emph{z3}) with a more efficient one. Every year a SAT competition \footnote{https://satcompetition.github.io/2024/results.html} is hosted and the most efficient SAT-Solver is awarded. Due to the modular structure of the implementation, exchanging the SAT-Solver is not too complex and would lead to a significant improvement.

The programs of \prog\ could also be extended in future work. The ability to build a faithful abstract AF based on a concrete AF would be a valuable improvement.

Furthermore, an empirical evaluation could be done, testing the efficiency of \prog\ compared to the related tool \emph{absarg-clustering}.