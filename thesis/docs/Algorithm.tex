\chapter{Algorithm}
In this chapter we have a closer look at the algorithms we designed and how they work. We provide an explanation, accompanied with an example and pseudo-code.
The first section explains, the concretization of a clustered argument \ref{sec:ConcretizingSingletons}. The next section explains, how the concretizer list (a list of clustered arguments which are mutated to singletons) is computed \ref{sec:ComputationOfConcretizerList}. The approach to compute faithful clustered AFs is describer in Section \ref{sec:AlgorithmicApproachToComputeFaifthulClusterings}. And finally we state the heuristics and refinements in \cref{sec:HeuristicsAndRefinements}

\section{Concretizing Singletons}
\label{sec:ConcretizingSingletons}
When operating on clustered AFs, a crucial mutation is to extract clustered arguments from a cluster and transform it to a singleton. This is called concretizing. When clustering singletons, the cluster inherits the attacks of the argument, concretizing is the inverse operation. This means, that it needs to revert the changes done by the clustering.
Concretizing a list of arguments is done iteratively by duplicating the abstract AF $\mathtt{\hat{F}}$ to create a new AF $\mathtt{\hat{F}'}$ and mutating it. The mutation is guided by five steps considering the unchanged abstract AF $\mathtt{\hat{F}}$ and the concrete AF $\mathtt{F}$. To improve the understanding of each step, we accompany the explanation with the example depicted in \cref{example:concretizationOfArguments}, where we concretize the arguments $\mathtt{a}$ and $\mathtt{b}$.

\vspace{0.3cm}

\vspace{0.3cm}
\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.475\textwidth}
        \centering
        \begin{tikzpicture}
            % Singletons
                \def \ax{0}   \def \ay{0}
                \def \bx{1}   \def \by{0}
                \def \cx{1}   \def \cy{-1}
                \def \dx{2}   \def \dy{0}
                \def \ex{2}   \def \ey{-1}
                \def \fx{3}   \def \fy{-1}

                \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
                \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
                \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
                \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
                \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};
                \draw[line width=0.3mm] (\fx, \fy) circle (0.3) node[anchor=center]{$f$};
                % Attacks
                \DrawAttackHorizontal{L}{\bx}{\by}{\ax}{\ay}
                \DrawAttackHorizontal{L}{\dx}{\dy}{\bx}{\by}

                \DrawAttackVertical{D}{\bx}{\by}{\cx}{\cy}
                \DrawAttackVertical{U}{\ex}{\ey}{\dx}{\dy}

                \DrawAttackDiagonal{NRL}{\cx}{\cy}{\ax}{\ay}
        \end{tikzpicture}
        \caption{Concrete AF $\mathtt{F}$}
        \label{fig:concrete_af}
    \end{subfigure}%
    \hfill
    \begin{subfigure}[b]{0.475\textwidth}
        \centering
        \begin{tikzpicture}
            % Singletons
            \def \dx{1}   \def \dy{0}
            \def \gx{0}   \def \gy{-1}
            \def \hx{1.9}   \def \hy{-1}

            \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
            % Cluster

            \node[rectangle, draw, line width=0.3mm] at (\gx, \gy) {$a,b,c$};
            \node at (\gx + 0.1, \gy+0.5) {$\hat{g}$};

            \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e,f$};
            \node at (\hx + 0.1, \hy+0.5) {$\hat{h}$};

            % Attacks
            \DrawAttackDiagonal{PRL}{\dx}{\dy}{\gx+0.1}{\gy+0.1}
            \DrawAttackDiagonal{NRL}{\hx}{\hy+0.1}{\dx}{\dy}
            \DrawSelfAttackLeftTopCluster{\gx-0.45}{\gy+0.3}
        \end{tikzpicture}
        \caption{Abstract AF $\mathtt{\hat{F}}$}
        \label{fig:abstract_af}
    \end{subfigure}

    \caption{Example: Concretization of arguments}
    \label{example:concretizationOfArguments}
\end{figure}


\vspace{-0.2cm}

\paragraph{Step 1:} Each argument needing concretization is first removed from the parent cluster and added as a singleton in $\mathtt{\hat{F}'}$.
If an argument is not part of a cluster, we ignore it.
We do not consider attacks in this step since they depend on the concrete- and abstract AFs. The resulting AF is depicted in \cref{example:algorithmConcretizeSingletonsStep1}.


\vspace{0.3cm}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \dx{2}   \def \dy{0}
        \def \gx{1}   \def \gy{-1}
        \def \hx{2.9}   \def \hy{-1}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        % Cluster

        \node[rectangle, draw, line width=0.3mm] at (\gx, \gy) {$a,b,c$};
        \node at (\gx + 0.1, \gy + 0.5) {$\hat{g}$};

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e,f$};
        \node at (\hx + 0.1, \hy + 0.5) {$\hat{h}$};

        % Attacks
        \DrawAttackDiagonal{PRL}{\dx}{\dy}{\gx+0.1}{\gy+0.1}
        \DrawAttackDiagonal{NRL}{\hx}{\hy+0.1}{\dx}{\dy}
        \DrawSelfAttackLeftTopCluster{\gx-0.45}{\gy+0.3}

    \end{tikzpicture}
    \caption{Concretized AF $\mathtt{\hat{F}'}$ after Step 1}
    \label{example:algorithmConcretizeSingletonsStep1}
\end{figure}
\vspace{-0.2cm}


\paragraph{Step 2:} We add the new attacks from all concretized arguments to the remaining clusters. We must do this after
removing the arguments from the clusters because if an argument $\mathtt{a}$ attacks argument $\mathtt{b}$ in the concrete AF, and $\mathtt{b}$ is part of the cluster $\mathtt{\hat{g}}$ in the abstract AF, by concretizing $\mathtt{b}$, the attack $\mathtt{(a,\hat{g})}$ would not be present anymore. The resulting AF is depicted in \cref{example:algorithmConcretizeSingletonsStep2}.


\vspace{0.3cm}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \dx{2}   \def \dy{0}
        \def \gx{1}   \def \gy{-1}
        \def \hx{2.9}   \def \hy{-1}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        % Cluster

        \node[rectangle, draw, line width=0.3mm] at (\gx, \gy) {$\phantom{a,} c\phantom{, b}$};
        \node at (\gx + 0.74, \gy + 0.2) {$\hat{g}$};

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e,f$};
        \node at (\hx + 0.1, \hy + 0.5) {$\hat{h}$};

        % Attacks
        \DrawAttackDiagonal{PRL}{\dx}{\dy}{\gx+0.1}{\gy+0.1}
        \DrawAttackDiagonal{NRL}{\hx}{\hy+0.1}{\dx}{\dy}
        \DrawSelfAttackLeftTopCluster{\gx-0.45}{\gy+0.3}
        \DrawAttackVertical{D}{\bx}{\by}{\gx}{\gy}
        \DrawAttackDiagonal{NRL}{\gx-0.1}{\gy+0.1}{\ax}{\ay}


    \end{tikzpicture}
    \caption{Concretized AF $\mathtt{\hat{F}'}$ after Step 2}
    \label{example:algorithmConcretizeSingletonsStep2}
\end{figure}
\vspace{-0.2cm}


\paragraph{Step 3:} After adding the new attacks, we need to check which attacks from $\mathtt{\hat{F}}$ are still present in $\mathtt{\hat{F}'}$. If an attack does not persist through the concretization, we remove it in $\mathtt{\hat{F}'}$. An attack is not present anymore; if we remove one of the arguments being attacked or attacked by argument $\mathtt{a}$ from a cluster $\mathtt{\hat{f}}$ and no other attack exists, s.t. $\mathtt{a}$ is attacked from/attacking an argument within $\mathtt{\hat{f}}$. Selfattacks of clusters could also change by the concretization of arguments. Therefore, we need to check the clusters from which the arguments are concretized. The resulting AF is depicted in \cref{example:algorithmConcretizeSingletonsStep3}.


\vspace{0.3cm}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \dx{2}   \def \dy{0}
        \def \gx{1}   \def \gy{-1}
        \def \hx{2.9}   \def \hy{-1}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        % Cluster

        \node[rectangle, draw, line width=0.3mm] at (\gx, \gy) {$\phantom{a,} c\phantom{, b}$};
        \node at (\gx + 0.74, \gy + 0.2) {$\hat{g}$};

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e,f$};
        \node at (\hx + 0.1, \hy + 0.5) {$\hat{h}$};

        % Attacks
        \DrawAttackDiagonal{NRL}{\hx}{\hy+0.1}{\dx}{\dy}
        \DrawAttackVertical{D}{\bx}{\by}{\gx}{\gy}
        \DrawAttackDiagonal{NRL}{\gx-0.1}{\gy+0.1}{\ax}{\ay}
    \end{tikzpicture}
    \caption{Concretized AF $\mathtt{\hat{F}'}$ after Step 3}
    \label{example:algorithmConcretizeSingletonsStep3}
\end{figure}
\vspace{-0.2cm}


\paragraph{Step 4:} In this step we add the new attacks between the singletons. Due to the fact, that we copied all the attacks from $\mathtt{\hat{F}}$, we only have to take into consideration the attacks from or to the concretized singletons. So instead of iterating over all singletons of the AF, we can limit the attack creation to the concretized singletons. The resulting AF is depicted in \cref{example:algorithmConcretizeSingletonsStep4}.


\vspace{0.3cm}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \dx{2}   \def \dy{0}
        \def \gx{1}   \def \gy{-1}
        \def \hx{2.9}   \def \hy{-1}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        % Cluster

        \node[rectangle, draw, line width=0.3mm] at (\gx, \gy) {$\phantom{a,} c\phantom{, b}$};
        \node at (\gx + 0.74, \gy + 0.2) {$\hat{g}$};

        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e,f$};
        \node at (\hx + 0.1, \hy + 0.5) {$\hat{h}$};

        % Attacks
        \DrawAttackDiagonal{NRL}{\hx}{\hy+0.1}{\dx}{\dy}
        \DrawAttackVertical{D}{\bx}{\by}{\gx}{\gy}
        \DrawAttackDiagonal{NRL}{\gx-0.1}{\gy+0.1}{\ax}{\ay}
        \DrawAttackHorizontal{L}{\dx}{\dy}{\bx}{\by}
        \DrawAttackHorizontal{L}{\bx}{\by}{\ax}{\ay}
    \end{tikzpicture}
    \caption{Concretized AF $\mathtt{\hat{F}'}$ after Step 4}
    \label{example:algorithmConcretizeSingletonsStep4}
\end{figure}
\vspace{-0.2cm}


\paragraph{Step 5:} The last step is to clean up the argumentation framework $\mathtt{\hat{F}'}$ by removing all empty clusters and mutating the clusters with exactly
one singleton to the mentioned singleton. The resulting AF is depicted in \cref{example:algorithmConcretizeSingletonsStep5}.


\vspace{0.3cm}
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \dx{2}   \def \dy{0}
        \def \cx{1}   \def \cy{-1}
        \def \hx{2.9}   \def \hy{-1}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        % Cluster
        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e,f$};
        \node at (\hx + 0.1, \hy + 0.5) {$\hat{h}$};

        % Attacks
        \DrawAttackDiagonal{NRL}{\hx}{\hy+0.1}{\dx}{\dy}
        \DrawAttackVertical{D}{\bx}{\by}{\cx}{\cy}
        \DrawAttackDiagonal{NRL}{\cx}{\cy}{\ax}{\ay}
        \DrawAttackHorizontal{L}{\dx}{\dy}{\bx}{\by}
        \DrawAttackHorizontal{L}{\bx}{\by}{\ax}{\ay}
    \end{tikzpicture}
    \caption{Concretized AF $\mathtt{\hat{F}'}$ after Step 5}
    \label{example:algorithmConcretizeSingletonsStep5}
\end{figure}
\vspace{-0.2cm}

The pseudo code is listed in \cref{alg:concretizingSingletons}.

\begin{algorithm}[H]
    \caption{Concretizing Singletons Pseudocode}\label{alg:concretizingSingletons}
    \begin{algorithmic}[1]
        \Require $A: AF(a_1, r_1)$ \Comment{Abstract Clustered AF}
        \Require $C: AF(a_2, r_2)$ \Comment{Abstract Concrete AF}
        \Require $e: list(Arguments)$ \Comment{concretizer list}
        \For{$e_i$ in $e$}
            \If{$e_i$ not in $C$ $\lor$ $e_i$ not in $A_{C}$} \Comment{$A_C$ = Cluster in $A$}
                \State $e$.remove($e_i$)
            \EndIf
        \EndFor
        \State $N$ $\gets$ $A$ \Comment{$N$ = Concretized Cluster}
        \State $N$.addSingletons($e$) \Comment{Step 1}
        \State $N_C$.removeArguments($e$)
        \For{$e_i$ in $e$} \Comment{Step 2}
            \For{$e_i$ attacks $A_c$}
                \State $N[e_i].attacks.append(A_c)$
            \EndFor
        \EndFor
        \For{$r_i$ in $A_r$} \Comment{Step 3}
            \If{$r_i$ not persists in $C$}
                \State $A_r.remove(r_i)$
            \EndIf
        \EndFor
        \For{$e_i$ in $e$} \Comment{Step 4}
            \For{$e_i$ attacks $C_a$}
                \State $N[e_i].attacks.append(C_a)$
            \EndFor
        \EndFor
        \For{$c_i$ in $N_c$} \Comment{Step 5}
            \If{$c_i.argAmount == 1$}
                \State $c_i \gets Singleton$
            \ElsIf{$c_i.argAmount == 0$}
                \State $N_c.remove(c_i)$
            \EndIf
        \EndFor
    \end{algorithmic}
\end{algorithm}


\newpage
\section{Computation of Concretizer List}
\label{sec:ComputationOfConcretizerList}
% Why do we need the algorithm
When talking about clustering AFs, faithfulness is an important property. If an AF is spurious, we found atleast one semantics extension, which cannot be mapped to a concrete extension. Based on the spurious extensions, we try to mutate the clustered AF, to obtain faithfulness. This mutation is realized through the concretizer list.

% What is concretizer list
The concretizer list is a list of sets of clustered arguments. Each set is a unique combination of arguments, which are being concretized to find a faithful AF. All the sets of the concretizer list are attempted iteratively, where the order is dependend on the size of the set. We use a heuristicical approach, putting the main focus on local changes. Here we operate directly on the arguments and its attackers which make a set spurious, instead of applying global changes to the AF. Further, a minimal deviation of the abstract AF is usually desired, so small concretizer sets are checked first.

% Input: spurious set
The input to the computation of the concretizer list is a set of the arguments of all the spurious semantic extensions. The size and computation intensity of the concretizer list is highly dependent on the amount of attacks, each argument of the input set and its neighbours with depth 2 have. This is also the critical part of the faithful AF computation and makes some AFs infeasible to solve.

% Example base
Let us have a look at an example to demonstrate how the concretizer list is computed. The concrete AF $\mathtt{G}$ is defined in \cref{af:algorithmConcretizer1} and the according abstract AF $\mathtt{\hat{G}}$ in \cref{af:algorithmConcretizer2}.


\vspace{0.3cm}
\begin{figure}[h]
\begin{minipage}{.5\textwidth}
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \cx{1}   \def \cy{-1}
        \def \dx{2}   \def \dy{0}
        \def \ex{3}   \def \ey{0}
        \def \fx{3}   \def \fy{-1}
        \def \gx{4}   \def \gy{0}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};
        \draw[line width=0.3mm] (\fx, \fy) circle (0.3) node[anchor=center]{$f$};
        \draw[line width=0.3mm] (\gx, \gy) circle (0.3) node[anchor=center]{$g$};

        % Attacks
        \DrawSelfAttackLeftSingleton{\ax}{\ay}
        \DrawAttackHorizontal{B}{\bx}{\by}{\ax}{\ay}
        \DrawAttackHorizontal{R}{\bx}{\by}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\dx}{\dy}
        \DrawAttackHorizontal{R}{\ex}{\ey}{\gx}{\gy}
        \DrawAttackVertical{B}{\bx}{\by}{\cx}{\cy}
        \DrawAttackVertical{D}{\ex}{\ey}{\fx}{\fy}
        \DrawAttackDiagonal{PLR}{\fx}{\fy}{\gx}{\gy}
    \end{tikzpicture}
    \caption{Concrete AF $\mathtt{G}$}
    \label{af:algorithmConcretizer1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \bx{0}   \def \by{0}
        \def \hx{2}   \def \hy{0}

        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};

        % Cluster
        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$a, c, d, e, f, g$};
        \node at (\hx + 0.1, \hy + 0.55) {$\hat{h}$};
        % Attacks
        \DrawAttackHorizontal{B}{\hx-0.85}{\hy}{\bx}{\by}
        \DrawSelfAttackRightTopCluster{\hx+1}{\hy+0.29}

    \end{tikzpicture}
    \caption{Abstract AF $\mathtt{\hat{G}}$}
    \label{af:algorithmConcretizer2}
\end{minipage}
\end{figure}
\vspace{0.3cm}

If we have a look at the stable extensions of the concrete AF $\mathtt{G}$, e.g. $\mathtt{stb=[\{b, c\}]}$ and at the stable extensions of the abstract AF $\mathtt{\hat{G}}$, e.g. $\mathtt{stb=[\{b, \hat{h}\}, \{\hat{h}\}, \{b\}]}$, we can see that stable extensions $\mathtt{\{\hat{h}\}}$ and $\mathtt{\{b\}}$ are spurious. The input to the concretizer list computation is a collection of the arguments of all the spurious sets, which in this case is $\mathtt{\{b, \hat{h}\}}$.

% Filter Cluster out of spurious set, because we cant concretize cluster
The first step is to filter out the clusters of the input, since clusters are not present in the concrete AF and therefore do not attack any singletons and are not being attacked. So we reduce the concretizer list from $\mathtt{\{b, \hat{h}\}}$ to $\mathtt{\{b\}}$.

% Get combination as attacker depth 2
% Get combination as defender depth 2
Next, we have a look at the neighbouring arguments of the current concretizer list.  Neighbours in this context are arguments which attack, or are being attacked by an argument. The depth defines how many arguments are between the attacks. A depth of $0$ is the actual argument, a depth of $1$ represents the direct attacker of the argument and the direct arguments, which are being attacked by the argument. A depth $2$ argument is an argument, which has some attack relation (e.g. attacks the argument or is attacked by the argument) with a depth $1$ argument.

We used a search depth of $2$ in our implementation. So when having a look at our example, we take the defender of depth $1$ and $2$, in \cref{af:algorithmConcretizer3} depicted in yellow and the attacker with the same depth, depicted in blue. Some arguments can have multiple depths (e.g. argument $\mathtt{c}$. It is a direct attacker of the argument $\mathtt{b}$ with depth $0$, but also a direct attacker of the argument $\mathtt{c}$ with depth $1$), than the lower depth is chosen as the representative.

%Depth 2 Attacker
\vspace{0.1cm}
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \cx{1}   \def \cy{-1}
        \def \dx{2}   \def \dy{0}
        \def \ex{3}   \def \ey{0}
        \def \fx{3}   \def \fy{-1}
        \def \gx{4}   \def \gy{0}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[cYellow] (\ax,\ay) circle (0.4);
        \node[text=cYellow] at (\ax+0.33, \ay+0.45) {\footnotesize 1};

        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[cRed] (\bx,\by) circle (0.4);
        \node[text=cRed] at (\bx+0.33, \by+0.45) {\footnotesize 0};

        \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
        \draw[cYellow] (\cx,\cy) circle (0.4);
        \node[text=cYellow] at (\cx+0.55, \cy) {\footnotesize 1};

        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};
        \draw[cBlue] (\dx,\dy) circle (0.4);
        \node[text=cBlue] at (\dx+0.33, \dy+0.45) {\footnotesize 1};

        \draw[line width=0.3mm] (\ex, \ey) circle (0.3) node[anchor=center]{$e$};
        \draw[cBlue] (\ex,\ey) circle (0.4);
        \node[text=cBlue] at (\ex+0.33, \ey+0.45) {\footnotesize 2};

        \draw[line width=0.3mm] (\fx, \fy) circle (0.3) node[anchor=center]{$f$};
        \node at (\fx+0.45, \fy) {\footnotesize 3};

        \draw[line width=0.3mm] (\gx, \gy) circle (0.3) node[anchor=center]{$g$};
        \node at (\gx+0.33, \gy+0.45) {\footnotesize 3};

        % Attacks
        \DrawSelfAttackLeftSingleton{\ax}{\ay}
        \DrawSelfAttackLeftSingleton{\cx}{\cy}
        \DrawAttackHorizontal{B}{\bx}{\by}{\ax}{\ay}
        \DrawAttackHorizontal{R}{\bx}{\by}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\ex}{\ey}{\dx}{\dy}
        \DrawAttackHorizontal{R}{\ex}{\ey}{\gx}{\gy}
        \DrawAttackVertical{B}{\bx}{\by}{\cx}{\cy}
        \DrawAttackVertical{D}{\ex}{\ey}{\fx}{\fy}
        \DrawAttackDiagonal{PLR}{\fx}{\fy}{\gx}{\gy}
    \end{tikzpicture}
    \caption{Singletons depth with $\mathtt{b}$ as viewpoint}
    \label{af:algorithmConcretizer3}
\end{figure}
\vspace{-0.2cm}

Now the concretizer list is expanded with all the possible combinations of the neighbours. The neighbours of the current example are $\mathtt{\{a, c, d, e\}}$. When building the combinations, we create the table defined in \cref{table:algorithmConcretizer1}.

\begin{table}[htb]
    \centering
    \begin{tabular}{ |c|c|c|c| }
     \hline
     size $1$ & size $2$ & size $3$ & size $4$\\
     \hline
     \hline
     $\mathtt{\{a\}}$ & $\mathtt{\{a, c\}}$ & $\mathtt{\{a, c, d\}}$ &$\mathtt{\{a, c, d, e\}}$ \\
     \hline
     $\mathtt{\{c\}}$ & $\mathtt{\{a, d\}}$ & $\mathtt{\{a, c, e\}}$ & \\
     \hline
     $\mathtt{\{d\}}$ & $\mathtt{\{a, e\}}$ & $\mathtt{\{a, d, e\}}$ & \\
     \hline
     $\mathtt{\{e\}}$ & $\mathtt{\{c, d\}}$ & $\mathtt{\{c, d, e\}}$ & \\
     \hline
       & $\mathtt{\{c, e\}}$ &  & \\
     \hline
       & $\mathtt{\{d, e\}}$ &  & \\
     \hline
    \end{tabular}
\caption{Combinations of $\mathtt{\{a, c, d, e\}}$}
\label{table:algorithmConcretizer1}

\end{table}

The combination table grows exponentially to the base of 2. Therefore, the size of the neighbours is crucial. If we have too many neighbours, the computation would need too much memory and turns infeasible to compute.

% Add concretizer list defined by the user
% deduplicate
If the user has provided arguments which have to be concretized as program argument, we add them to each combination set. After adding them, we filter for duplicates to keep the concretizer list size to a minimum.

% Filter singletons which are not in cluster, because cant concretize singletons
% deduplicate
Next, we need to filter out the arguments, which are not in clusters, since singletons are already concrete. This filtering could lead to some duplicates again, which we need to remove once again to minimize the memory consumption and reduce the amount of faitfhul checks.

Finally, we sort the list by the set size and return it. In the current example we would return the whole table, because no concretizer arguments were provided by the user. So the concretizer list would be
$\mathtt{[\{a\}}$
$\mathtt{\{b\}}$
$\mathtt{\{c\}}$
$\mathtt{\{d\}}$
$\mathtt{\{a, c\}}$
$\mathtt{\{a, d\}}$
$\mathtt{\{a, e\}}$
$\mathtt{\{c, d\}}$
$\mathtt{\{c, e\}}$
$\mathtt{\{d, e\}}$
$\mathtt{\{a, c, d\}}$
$\mathtt{\{a, c, e\}}$
$\mathtt{\{a, d, e\}}$
$\mathtt{\{c, d, e\}}$
$\mathtt{\{a, c, d, e\}]}$.

When concretizing the list, we find a set which leads to a faithful AF: $\mathtt{\{a, c, d\}}$ depicted in \cref{af:algorithmConcretizer4}. The pseudo code of the computation is listed in \cref{alg:concretizerList}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        % Singletons
        \def \ax{0}   \def \ay{0}
        \def \bx{1}   \def \by{0}
        \def \cx{1}   \def \cy{-1}
        \def \dx{2}   \def \dy{0}
        \def \hx{3.5}   \def \hy{0}

        \draw[line width=0.3mm] (\ax, \ay) circle (0.3) node[anchor=center]{$a$};
        \draw[line width=0.3mm] (\bx, \by) circle (0.3) node[anchor=center]{$b$};
        \draw[line width=0.3mm] (\cx, \cy) circle (0.3) node[anchor=center]{$c$};
        \draw[line width=0.3mm] (\dx, \dy) circle (0.3) node[anchor=center]{$d$};

        % Cluster
        \node[rectangle, draw, line width=0.3mm] at (\hx, \hy) {$e, f, g$};
        \node at (\hx + 0.1, \hy + 0.55) {$\hat{h}$};
        % Attacks
        \DrawAttackHorizontal{B}{\hx-0.3}{\hy}{\dx}{\dy}
        \DrawAttackHorizontal{B}{\bx}{\by}{\ax}{\ay}
        \DrawAttackHorizontal{R}{\bx}{\by}{\dx}{\dy}
        \DrawAttackVertical{B}{\bx}{\by}{\cx}{\cy}
        \DrawSelfAttackRightTopCluster{\hx+0.45}{\hy+0.29}
        \DrawSelfAttackLeftSingleton{\ax}{\ay}

    \end{tikzpicture}
    \caption{Faithful AF $\mathtt{\hat{G}'}$}
    \label{af:algorithmConcretizer4}
\end{figure}



\begin{algorithm}
    \caption{Computation of Concretizer list Algorithm}\label{alg:concretizerList}
    \begin{algorithmic}[1]
        \Require $G: AF(a_1, r_1)$ \Comment{Concrete AF}
        \Require $\hat{G}: AF(a_2, r_2)$ \Comment{Abstract AF}
        \Require $s: list(Arguments)$ \Comment{spurious arguments}
        \Require $ca: list(Arguments)$ \Comment{Concretize arguments parameter}
        \For{$s_i$ in $s$}
            \If{$s_i$ in $\hat{G}$ is cluster}
                \State $s$.remove($s_i$)
            \EndIf
        \EndFor
        \State $N$ $\gets$ $[]$ \Comment{$N$ = list of neighbours}
        \For{$s_i$ in $s$} \Comment{Get neighbours}
            \For{$n(1)_i$ attacks $s_i$} \Comment{depth 1 attacker}
                \For{$n(2)_i$ attacks $n(1)_i$} \Comment{depth 2 attacker}
                    \State $N.append(n(2)_i$)
                \EndFor
                \For{$n(2)_i$ defends $n(1)_i$} \Comment{depth 2 defender}
                    \State $N.append(n(2)_i$)
                \EndFor
            \EndFor

            \For{$n(1)_i$ defends $s_i$} \Comment{depth 1 defender}
                \For{$n(2)_i$ attacks $n(1)_i$} \Comment{depth 2 attacker}
                    \State $N.append(n(2)_i$)
                \EndFor
                \For{$n(2)_i$ defends $n(1)_i$} \Comment{depth 2 defender}
                    \State $N.append(n(2)_i$)
                \EndFor
            \EndFor
        \EndFor
        \State $C \gets$ combinations of N with $range(1, len(N)-1)$ \Comment{Combination List}

        \For{$ca_i$ in $ca$} \Comment{Parameter Arguments to be concretized}
            \For{$c_i$ in $C$}
                \State $c_i.append(ca_i)$
            \EndFor
        \EndFor
        \State $C.deduplicate()$
        
        \For{$s_i$ in $C$} \Comment{Remove clusters}
            \For{$a_i$ in $s_i$}
                \If{$\hat{G}[a_i]$ is cluster}
                    \State $s_i.remove(a_i)$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}



% return list






\newpage
\section{Algorithmic Approach to Compute Faifthul Clusterings}
\label{sec:AlgorithmicApproachToComputeFaifthulClusterings}
\textit{TODO: Concretize singletons of clustered AF algorithm}

\section{Heuristics and Refinements}
\label{sec:HeuristicsAndRefinements}
\textit{TODO: Define every Heuristic and refinement we used for each semantic}
